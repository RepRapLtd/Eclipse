/**
 * This program reads a list of triangles from an STL file, which have no imposed structure.
 * 
 * It attempts to stitch them together to form meshes of triangles where each triangle has
 * three corners in space and opposite them three sides.  Each side connects to another triangle 
 * in the mesh.  The result is then written to a new file with all that structure intact.
 * 
 * A certain amount of checking for integrity and solidity is done.
 * 
 */
package com.reprapltd.triangulator;

import java.util.ArrayList;

import org.j3d.renderer.java3d.loaders.STLLoader;
import javax.vecmath.Point3d;

/**
 * @author Adrian Bowyer
 * 
 * RepRap Ltd
 * https://reprapltd.com
 * 
 * Licence: GPL
 *
 */


public class Triangulator 
{
	private CornerList corners = new CornerList();
	private double smallD2 = 0.001;
	private ArrayList<Triangle> meshes = new ArrayList<Triangle>();
	
	public class CornerList
	{
		/**
		 * This stores the list of vertices/corners of all the triangles as points in space.  Each
		 * point will have a ring of triangles around it.  The points all have one arbitrary triangle
		 * stored alongside them (from which the ring can be derived by a local search).
		 */
		private ArrayList<Point3d> corners = new ArrayList<Point3d>();
		private ArrayList<Triangle> triangles = new ArrayList<Triangle>();
		
		/**
		 * Add a triangle corner to the list, together with any
		 * triangle that has that corner.  It returns the index of
		 * the corner.
		 * 
		 * @param corner
		 * @param triangle
		 * @return
		 */
		public int AddCorner(Point3d corner, Triangle triangle)
		{
			corners.add(corner);
			triangles.add(triangle);
			return corners.size() - 1;
		}
		
		public Point3d GetCorner(int i)
		{
			return corners.get(i);
		}
		
		public Triangle GetTriangle(int i)
		{
			return triangles.get(i);
		}
		
		/**
		 * This finds the point in the list corresponding to target and
		 * returns its index.  Any point with squared distance to target
		 * less than or equal to smallD2 is considered a match.  If no such 
		 * point is found -1 is returned.
		 * 
		 * TODO: Obviously this should not do an exhaustive search; it
		 * should use a spatial structure (BSP tree?).
		 * 
		 * @param target
		 * @return
		 */
		public int Find(Point3d target)
		{
			for(int i = 0; i < corners.size(); i++)
			{
				if(corners.get(i).distanceSquared(target) <= smallD2)
					return i;
			}
			return -1;
		}
	}
	
	public class Triangle 
	{

		/**
		 * This holds the representation of a single triangle.  A triangle
		 * has corners and, opposite them, edges.  Each edge is the adjacent triangle
		 * in the mesh.  For a complete mesh no edges should be null.  The corners
		 * are stored as indices into the CornerList, where the actual point coordinates
		 * in space are kept.
		 */
		
		private int cornerIndices[];
		private Triangle edges[];
		
		/**
		 * visited is a flag to facilitate recursively walking over the mesh
		 */
		
		private boolean visited;
		
		private Triangle()
		{
			visited = false;
			cornerIndices = new int[3];
			edges = new Triangle[3];
			for(int i = 0; i < 3; i++)
			{
				cornerIndices[i] = -1;
				edges[i] = null;
			}
		}
		
		public Triangle(Point3d aC, Point3d bC, Point3d cC) 
		{
			this();
			
			int c = corners.Find(aC);
			if(c < 0)
				c = corners.AddCorner(aC,  this);
			cornerIndices[0] = c;
			
			c = corners.Find(bC);
			if(c < 0)
				c = corners.AddCorner(bC,  this);
			cornerIndices[1] = c;
			
			c = corners.Find(cC);
			if(c < 0)
				c = corners.AddCorner(cC,  this);
			cornerIndices[2] = c;
		}
		
		public void Error(String s)
		{
			
		}
		
		public void ResetVisited()
		{
			visited = false;
		}
		
		public void MarkVisited()
		{
			visited = true;
		}
		
		public boolean Visited()
		{
			return visited;
		}
		
		/**
		 * Reset all the triangles in one mesh to unvisited, starting with this one.
		 * Note this works with partial triangulations with null edges as long as they
		 * are not disjoint.
		 */
		
		public void Reset()
		{
			ResetVisited();
			for(int i = 0; i < 3; i++)
			{
				if(edges[i] != null)
					if(edges[i].Visited())
						edges[i].Reset();
			}
		}
		
		/**
		 * The vector product of corners ([1] - [0])x([2] - [0]) faces
		 * outward from solid to air.  This inverts a triangle that has 
		 * the wrong sense. 
		 */
		
		public void Invert()
		{
			int cTemp = cornerIndices[2];
			cornerIndices[2] = cornerIndices[1];
			cornerIndices[1] = cTemp;
			Triangle eTemp = edges[2];
			edges[2] = edges[1];
			edges[1] = eTemp;
		}
		
		public void SetEdge(Triangle e, int i)
		{
			edges[i] = e;
		}
		
		public boolean HasCorner(int corner)
		{
			for(int i = 0; i < 3; i++)
			{
				if(cornerIndices[i] == corner)
					return true;
			}		
			return false;
		}		
		
		public boolean HasCorners(int corner1, int corner2)
		{
			return HasCorner(corner1) && HasCorner(corner2);
		}
		
		public int AddPair(int corner, ArrayList<Triangle> tList)
		{
			int result = 0;
			
			for(int i = 0; i < 3; i++)
			{
				if(cornerIndices[i] != corner)
				{
					Triangle t = edges[i];
					if(t != null)
					{
						if(!t.Visited())
						{
							tList.add(t);
							t.MarkVisited();
							result++;
						}
					}
				}
			}
			
			return result;
		}
		
		public int FindRing(int corner, ArrayList<Triangle> tList)
		{	
			int added = 0;
			
			if(!HasCorner(corner))
			{
				Error("FindRing() called for absent corner!");
				return -1;
			}
			
			tList.add(this);
			MarkVisited();
			added++;
			
			added += AddPair(corner, tList);

		}
		
		/*
		
		private Triangle FindNeighbourR(int corner1, int corner2, ArrayList<Triangle> beenThere)
		{
			Triangle t = corners.GetTriangle(corner1);
			if(!t.Visited())
			{
				beenThere.add(t);
				t.MarkVisited();
				if(t.HasCorners(corner1, corner2))
				{
					return t;
				} else
					return t.FindNeighbourR(corner1, corner2, beenThere); 
			}
			
			return null;
		}
		
		public Triangle FindNeighbour(int corner1, int corner2)
		{
			ArrayList<Triangle> beenThere = new ArrayList<Triangle>();
			beenThere.add(this);
			MarkVisited();
			
			Triangle t = FindNeighbourR(corner1, corner2, beenThere);
			if(t == null)
				t = FindNeighbourR(corner2, corner1, beenThere);
			
			for(int i = 0; i < beenThere.size(); i++)
				beenThere.get(i).ResetVisited();
			
			return t;
		}
*/
	}


	/**
	 * 
	 */
	public Triangulator() 
	{
		
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) 
	{
		

	}

}
